!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t=t||self).Honeycomb={})}(this,(function(t){"use strict";"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var n=function(t,n){return t(n={exports:{}},n.exports),n.exports}((function(t,n){t.exports=function(){var t={},n="Array Object String Date RegExp Function Boolean Number Null Undefined".split(" ");function e(){return Object.prototype.toString.call(this).slice(8,-1)}for(var r=n.length;r--;)t["is"+n[r]]=function(t){return function(n){return e.call(n)===t}}(n[r]);return t}()})),e=n.isObject,r=n.isNumber,i=n.isArray,o=n.isString;function s(t,n){return n+t*(1&n)>>1}function u(t,n){return(t%n+n)%n}function c(t,n){if(!/^(N|S)?(E|W)?$/i.test(t))throw new Error("Invalid compass direction: ".concat(t,". Choose from E, SE, S, SW, W, NW, N or NE."));if(n=n.toLowerCase(),t=t.toUpperCase(),"pointy"===n&&["N","S"].includes(t))throw new Error("Direction ".concat(t," is ambiguous for pointy hexes. Did you mean ").concat(t,"E or ").concat(t,"W?"));if("flat"===n&&["E","W"].includes(t))throw new Error("Direction ".concat(t," is ambiguous for flat hexes. Did you mean N").concat(t," or S").concat(t,"?"));return{pointy:{E:0,SE:1,SW:2,W:3,NW:4,NE:5},flat:{SE:0,S:1,SW:2,NW:3,N:4,NE:5}}[n][t]}function a(t,n){return r(t)||r(n)?r(t)?r(n)||(n=t):t=n:t=n=0,{x:t,y:n}}const h=[{q:1,r:0,s:-1},{q:0,r:1,s:-1},{q:-1,r:1,s:0},{q:-1,r:0,s:1},{q:0,r:-1,s:1},{q:1,r:-1,s:0}],l=[{q:2,r:-1,s:-1},{q:1,r:1,s:-2},{q:-1,r:2,s:-1},{q:-2,r:1,s:1},{q:-1,r:-1,s:2},{q:1,r:-2,s:1}],f={x:1e-6,y:1e-6};function d(t){return r(t)?this[t]:this[this.indexOf(t)]}function x(t){let{isValidHex:n}=t;return function(t,e){if(!n(e))return this;const i=r(t)?t:this.indexOf(t);return i<0?this.push(e):this[i]=e,this}}function y(t,n){const e=t.distance(n),r=1/Math.max(e,1);let i=[];for(let o=0;o<=e;o++){const e=t.nudge().lerp(n.nudge(),r*o).round();i.push(this.get(e))}return i}function g(t){let{isValidHex:n}=t;return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(!n(t))throw new Error("Invalid center hex: ".concat(t,"."));if(!this.get(t))throw new Error("Center hex with coordinates ".concat(t," not present in grid."));let i=[];for(let n=-e;n<=e;n++)for(let o=Math.max(-e,-n-e);o<=Math.min(e,-n+e);o++){const e=this.get(t.cubeToCartesian({q:t.q+n,r:t.r+o}));t.equals(e)&&!r||i.push(e)}return i.filter(Boolean)}}function p(t){let{isValidHex:n,signedModulo:e,compassToNumberDirection:r}=t;return function(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"all",s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!n(t))throw new Error("Invalid hex: ".concat(t,"."));const u=s?l:h;return"all"===i&&(i=[0,1,2,3,4,5]),[].concat(i).map(n=>{o(n)&&(n=r(n,t.orientation)),(n<0||n>5)&&(n=e(n,6));const{q:i,r:s}=u[n];return this.get(t.cubeToCartesian({q:t.q+i,r:t.r+s}))})}}function b(){if(0===this.length)return 0;const{0:t,length:n,[n-1]:e}=this[0].isPointy()?[...this].sort((t,n)=>n.s-t.s||t.q-n.q):[...this].sort((t,n)=>t.q-n.q);return e.toPoint().x-t.toPoint().x+this[0].width()}function q(){if(0===this.length)return 0;const{0:t,length:n,[n-1]:e}=this[0].isPointy()?[...this].sort((t,n)=>t.r-n.r):[...this].sort((t,n)=>n.s-t.s||t.r-n.r);return e.toPoint().y-t.toPoint().y+this[0].height()}function P(t){let{Hex:n}=t;return function(t,e){return n().fromPoint(t,e)}}function w(t){let{Grid:n,Hex:e}=t;return function(t){let{width:r,height:i,start:o,direction:s=1,onCreate:u=(()=>{})}=t;o=e(o);const[c,a,h]={1:["q","r","s"],3:["r","s","q"],5:["s","q","r"]}[s],l=new n;l.width=r,l.height=i,l.start=o,l.direction=s;for(let t=0;t<r;t++)for(let n=0;n<i;n++){const r=e({[c]:t+o[c],[a]:n+o[a],[h]:-t-n+o[h]});u(r,l),l.push(r)}return l}}function m(t){let{Grid:n,Hex:e}=t;return function(t){let{size:r,start:i,direction:o=1,onCreate:s=(()=>{})}=t;i=e(i);const u={1:{rStart:()=>0,rEnd:t=>r-t},5:{rStart:t=>r-t,rEnd:()=>r+1}},{rStart:c,rEnd:a}=u[o],h=new n;h.size=r,h.start=i,h.direction=o;for(let t=0;t<r;t++)for(let n=c(t);n<a(t);n++){const r=e({q:t+i.q,r:n+i.r,s:-t-n+i.s});s(r,h),h.push(r)}return h}}function H(t){let{Grid:n,Hex:e}=t;return function(t){let{radius:r,center:i,onCreate:o=(()=>{})}=t;i=e(i);const s=new n;s.radius=r,s.center=i;for(let t=-r;t<=r;t++){const n=Math.max(-r,-t-r),u=Math.min(r,-t+r);for(let r=n;r<=u;r++){const n=e({q:t+i.q,r:r+i.r,s:-t-r+i.s});o(n,s),s.push(n)}}return s}}function O(t){let{Grid:n,Hex:e,compassToNumberDirection:r,signedModulo:i}=t;return function(t){let{width:u,height:c,start:a,direction:h=(e().isPointy()?0:1),onCreate:l=(()=>{})}=t;a=e(a),o(h)&&(h=r(h,a.orientation)),(h<0||h>5)&&(h=i(h,6));const[f,d,x]=[["q","r","s"],["r","q","s"],["r","s","q"],["s","r","q"],["s","q","r"],["q","s","r"]][h],[y,g]=a.isPointy()?[u,c]:[c,u],p=new n;p.width=u,p.height=c,p.start=a,p.direction=h;for(let t=0;t<g;t++){const n=s(a.offset,t);for(let r=-n;r<y-n;r++){const n=e({[f]:r+a[f],[d]:t+a[d],[x]:-r-t+a[x]});l(n,p),p.push(n)}}return p}}function v(t){let{Grid:n,Hex:e}=t;return function(t){let{radius:r,center:i,onCreate:o=(()=>{})}=t;i=e(i);const s=new n;s.radius=r,s.center=i;const{q:u,r:c,s:a}=i;let l=e({q:u,r:c-r,s:a+r});for(let t=0;t<6;t++)for(let n=0;n<r;n++){o(l,s),s.push(l);const{q:n,r:r,s:i}=h[t];l=e({q:l.q+n,r:l.r+r,s:l.s+i})}return s}}function j(t){let{Grid:n,Hex:e}=t;return function(t){let{radius:r,center:i,onCreate:o=(()=>{})}=t;i=e(i);let s=new n;o(i,s),s.push(i);for(let t=1;t<=r;t++)s=s.concat(this.ring({radius:t,center:i,onCreate:o}));return s.radius=r,s.center=i,s}}function M(t){let{Point:n}=t;return function(t,e){let r;return({x:r,y:e}=n(t,e)),n(this.x+r,this.y+e)}}function E(t){let{Point:n}=t;return function(t,e){let r;return({x:r,y:e}=n(t,e)),n(this.x-r,this.y-e)}}function C(t){let{Point:n}=t;return function(t,e){let r;return({x:r,y:e}=n(t,e)),n(this.x*r,this.y*e)}}function S(t){let{Point:n}=t;return function(t,e){let r;return({x:r,y:e}=n(t,e)),n(this.x/r,this.y/e)}}function N(t){let{ensureXY:n}=t;const o={add:M({Point:s}),subtract:E({Point:s}),multiply:C({Point:s}),divide:S({Point:s})};function s(t,s){let u;return u=r(t)?n(t,s):i(t)?n(...t):e(t)?n(t.x,t.y):n(0),Object.assign(Object.create(o),u)}return s}const R=N({ensureXY:a});class G extends Array{static isValidHex(t){return!0===(t||{}).__isHoneycombHex}fill(){throw new TypeError("Grid.prototype.fill is not implemented")}includes(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return!!(this.indexOf(t,n)+1)}indexOf(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const{length:e}=this;let r=Number(n);for(t=R(t),r=Math.max(r>=0?r:e+r,0);r<e;r++)if(this[r].equals(t))return r;return-1}lastIndexOf(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.length-1;const{length:e}=this;let r=Number(n);for(t=R(t),r=r>=0?Math.min(r,e-1):e+r;r>=0;r--)if(this[r].equals(t))return r;return-1}push(){for(var t=arguments.length,n=new Array(t),e=0;e<t;e++)n[e]=arguments[e];return super.push(...n.filter(G.isValidHex))}splice(t,n){if(null==n)return super.splice(t);for(var e=arguments.length,r=new Array(e>2?e-2:0),i=2;i<e;i++)r[i-2]=arguments[i];return super.splice(t,n,...r.filter(G.isValidHex))}unshift(){for(var t=arguments.length,n=new Array(t),e=0;e<t;e++)n[e]=arguments[e];return super.unshift(...n.filter(G.isValidHex))}}function T(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function D(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,r)}return e}function z(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?D(e,!0).forEach((function(n){T(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):D(e).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function V(t,n){if(null==t)return{};var e,r,i=function(t,n){if(null==t)return{};var e,r,i={},o=Object.keys(t);for(r=0;r<o.length;r++)e=o[r],n.indexOf(e)>=0||(i[e]=t[e]);return i}(t,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(r=0;r<o.length;r++)e=o[r],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(i[e]=t[e])}return i}function W(t){let{Hex:n}=t;return function(){return Object.assign(this,n(...arguments))}}function A(){return{x:this.x,y:this.y}}function I(){return{q:this.q,r:this.r,s:this.s}}function _(t){let n,e,{q:r,r:i}=t;return this.isPointy()?(n=r+s(this.offset,i),e=i):(n=r,e=i+s(this.offset,r)),{x:n,y:e}}function X(t){let{Point:n}=t;return function(t,e){let r,i,o;return({x:r,y:e}=n(t,e)),this.isPointy()?(i=r-s(this.offset,e),o=e):(i=r,o=e-s(this.offset,r)),{q:i,r:o,s:-i-o}}}function Y(){return"pointy"===this.orientation.toLowerCase()}function B(){return"flat"===this.orientation.toLowerCase()}function L(){const{xRadius:t}=this.size;return this.isPointy()?t*Math.sqrt(3):2*t}function k(){const{yRadius:t}=this.size;return this.isPointy()?2*t:t*Math.sqrt(3)}function F(t){let{Point:n}=t;return function(){const t=this.width(),e=this.height(),{x:r,y:i}=this.origin;return this.isPointy()?[n(t-r,.25*e-i),n(t-r,.75*e-i),n(.5*t-r,e-i),n(0-r,.75*e-i),n(0-r,.25*e-i),n(.5*t-r,0-i)]:[n(t-r,.5*e-i),n(.75*t-r,e-i),n(.25*t-r,e-i),n(0-r,.5*e-i),n(.25*t-r,0-i),n(.75*t-r,0-i)]}}function U(t){let{Point:n}=t;return function(){const{x:t,y:e}=this.origin;return n(this.width()/2-t,this.height()/2-e)}}function J(t){let{Point:n}=t;return function(){const{q:t,r:e,size:r}=this,{xRadius:i,yRadius:o}=r;let s,u;return this.isPointy()?(s=i*Math.sqrt(3)*(t+e/2),u=3*o/2*e):(s=3*i/2*t,u=o*Math.sqrt(3)*(e+t/2)),n(s,u)}}function $(t){let{Point:n,Hex:e}=t;return function(t,r){const{xRadius:i,yRadius:o}=this.size;let s,u,c;return({x:s,y:r}=n(t,r).subtract(this.center())),this.isPointy()?(u=Math.sqrt(3)*s/(3*i)-r/(3*o),c=2/3*(r/o)):(u=2/3*(s/i),c=Math.sqrt(3)*r/(3*o)-s/(3*i)),e({q:u,r:c,s:-u-c}).round()}}function K(t){let{Hex:n,Point:e}=t;return function(t){const{x:r,y:i}=e(t);return n(this.x+r,this.y+i,z({},this))}}function Q(t){let{Hex:n,Point:e}=t;return function(t){const{x:r,y:i}=e(t);return n(this.x-r,this.y-i,z({},this))}}function Z(t){let{Point:n}=t;return function(t){if(null!=t&&(i(t)||r(t.x)&&r(t.y))){const{x:e,y:r}=n(t);return this.x===e&&this.y===r}return!1}}function tt(t){return Math.max(Math.abs(this.q-t.q),Math.abs(this.r-t.r),Math.abs(this.s-t.s))}function nt(t){let{Hex:n}=t;return function(){let{q:t,r:e,s:r}=this,i=Math.round(t),o=Math.round(e),s=Math.round(r);const u=Math.abs(t-i),c=Math.abs(e-o),a=Math.abs(r-s);return u>c&&u>a?i=-o-s:c>a?o=-i-s:s=-i-o,n(z({},this,{q:i,r:o,s:s}))}}function et(t){let{Hex:n}=t;return function(t,e){const r=this.q*(1-e)+t.q*e,i=this.r*(1-e)+t.r*e;return n(z({},this,{q:r,r:i,s:-r-i}))}}function rt(){return this.add(f)}function it(){return"".concat(this.x,",").concat(this.y)}const ot={thirdCoordinate:function(t,n){return-t-n}};const st=N({ensureXY:a}),ut=function(t){let{ensureXY:n,normalizeRadiuses:o,Point:s}=t;return function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const u=X({Point:s}),c={__isHoneycombHex:!0,orientation:"pointy",origin:0,size:{xRadius:1,yRadius:1},offset:-1,get q(){return this.cartesianToCube(this).q},get r(){return this.cartesianToCube(this).r},get s(){return this.cartesianToCube(this).s},add:K({Hex:h,Point:s}),cartesian:A,cartesianToCube:u,center:U({Point:s}),coordinates:A,corners:F({Point:s}),cube:I,cubeToCartesian:_,distance:tt,equals:Z({Point:s}),fromPoint:$({Point:s,Hex:h}),height:k,isFlat:B,isPointy:Y,lerp:et({Hex:h}),nudge:rt,round:nt({Hex:h}),set:W({Hex:h}),subtract:Q({Hex:h,Point:s}),toCartesian:_,toCube:u,toPoint:J({Point:s}),toString:it,width:L},a=Object.assign(c,t);function h(t,o){let s,u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(e(t)){let{q:n,r:e,s:i}=t,c=V(t,["q","r","s"]);if(r(n)||r(e)||r(i)){if(n+e+i!==0)throw new Error("Cube coordinates must have a sum of 0. q: ".concat(n,", r: ").concat(e,", s: ").concat(i,", sum: ").concat(n+e+i,"."));({x:s,y:o}=a.cubeToCartesian({q:n,r:e,s:i}))}else({x:s,y:o}=t);u=c}else i(t)?([s,o]=t,u={}):s=t;return Object.assign(Object.create(a),Object.assign(u,n(s,o)))}return a.size=o(a.size,a.isPointy()),a.origin=s(a.origin),Object.assign(h,ot,{toJSON:()=>t}),h}}({ensureXY:a,normalizeRadiuses:function(t,n){if(e(t)){if(r(t.xRadius)&&r(t.yRadius))return t;const{width:e,height:i}=t;if(r(e)&&r(i))return n?{xRadius:e/Math.sqrt(3),yRadius:i/2}:{xRadius:e/2,yRadius:i/Math.sqrt(3)}}if(r(t))return{xRadius:t,yRadius:t};throw new Error("Invalid size: ".concat(t,". Set it as a number or as an object containing width and height."))},Point:st}),ct=function(t){let{extendHex:n,Grid:e,Point:o}=t;const{isValidHex:s}=e;return function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n();function a(){for(var n=arguments.length,o=new Array(n),s=0;s<n;s++)o[s]=arguments[s];return o=o.filter(Boolean),i(o[0])&&(0===o[0].length||o[0].some(t=>!r(t)))&&(o=o[0]),new e(...o.map(n=>t(n)))}return Object.assign(a,{Hex:t,isValidHex:s,pointToHex:P({Point:o,Hex:t}),parallelogram:w({Grid:e,Hex:t}),triangle:m({Grid:e,Hex:t}),hexagon:H({Grid:e,Hex:t}),rectangle:O({Grid:e,Hex:t,compassToNumberDirection:c,signedModulo:u}),ring:v({Grid:e,Hex:t}),spiral:j({Grid:e,Hex:t})}),Object.assign(e.prototype,{get:d,hexesBetween:y,hexesInRange:g({isValidHex:s}),neighborsOf:p({isValidHex:s,signedModulo:u,compassToNumberDirection:c}),pointHeight:q,pointWidth:b,set:x({isValidHex:s})}),a}}({extendHex:ut,Grid:G,Point:st});t.Point=st,t.defineGrid=ct,t.extendHex=ut,Object.defineProperty(t,"__esModule",{value:!0})}));
